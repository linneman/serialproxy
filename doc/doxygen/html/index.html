<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>serialproxy: Proxy Daemon for Serial Line Communication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">serialproxy
   &#160;<span id="projectnumber">0.0.1-g9ef4233</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Proxy Daemon for Serial Line Communication </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Object</h2>
<p>UART interfaces are still widely used in embedded system applications today e.g. with respect to automotive applications in order to interconnect a Linux based embedded CPU with an CAN Microcontroller. On contrast to Linux pipes UART's provide a bidirectional communication. As a consequence an existing implementation which uses the posix serial API cannot be transparently used with named pipes in Linux nor can it make use of socket based communication without changing the exting implemenation. The present sample application illustrates how to overcome this problem using <a href="https://en.wikipedia.org/wiki/Pseudoterminal">pseudo terminal devices</a>. This allows in example to transparently exchange a low level transport layer between CAN and CPU without affecting an application on top of it. The implementation has been inspired by the article <a href="http://rachid.koucha.free.fr/tech_corner/pty_pdip.html">Using pseudo-terminals (pty) to control interactive programs</a>.</p>
<h2>How to build.</h2>
<h3>Build Dependencies</h3>
<p>In addition to the commonly used Unix system libraries and build tools such as libc, pthreads and the autobuild suite, serialproxy depends on two utitily libraries, libcutils and libintercom which are maintained by the same author. You will need to compile and install these libraries on your system first. The libraries are both provided under the license terms of the LGPL. Refer to the installation instructions on Github for <a href="https://github.com/linneman/libcutils">libcutils</a> and <a href="https://github.com/linneman/libintercom">libintercom</a> for further explanation how to do this.</p>
<h3>Download and Compile on a Host System</h3>
<p>Compiling a host version of serialproxy is done in the very same way as for libcutils and libintercom following the guidelines of the free software foundation: </p><pre class="fragment">git clone git://github.com/linneman/serialproxy.git
cd serialproxy

./autoreconf -i # for config script generation

./configure
make
make install # as root
</pre><p>In case you have downloaded an official release as gzipped tarball you will exclusively need the last three commands since the configure script is already delivered with stable releases.</p>
<p>Pay attention to the fact that add on libraries are per default installed under the directory <code>/usr/local/lib</code> which is not in the library path on many linux distributions. Thus you will need to put <code>/usr/local/lib</code> to your library path e.g. by defining the enviroment variable </p><pre class="fragment">export LD_LIBRARY_PATH=/usr/local/lib.
</pre><p>Alternatively, you can edit <code>/etc/ld.so.conf</code> which contains the default directories searched. Note that you may also need to update the cache <code>/etc/ld.so.cache</code> by running ldconfig (as root or with sudo).</p>
<h3>Compilation on OpenEmbedded</h3>
<p>Crosscompiling serialproxy with OpenEmbedded/Yocto is started by the command within the build shell where the build enviroment has been previously sourced: </p><pre class="fragment">bitbake serialproxy
</pre><p>Refer in example to the OpenNAD platform for further information.</p>
<h2>Fundamental Concepts</h2>
<p>The serialproxy daemon instantiates a background thread which executes the function 'proxy_handler' implemented in source file proxy.c. This handler reads data from two device files, one refers to the physical UART, the other one refers to the master side of the pseudo terminal session which is created in the initialization phase in the same module. The read data is written to the other's descriptor after transferring lower to upper characters to illustrates that the underlying data stream can be in fact altered. Furthermore a symbolic link to the slave side of the pseudo terminal is created to be in example accessed by an existing application instead of directly writing and reading from the UART.</p>
<p>Please note that the current implementation of serialproxy does not setup the serial port parameters. You need to do this externally in example by invoking the system command stty.</p>
<p>The daemon creates a server which by default listens to TCP port 6000 and to the unix domain socket refered by /tmp/serialproxy.sock. The corresponding implementation is located under the source file control.c within the call back handler 'crtl_server_event_handler'. You can easily add more commands for your needs there.</p>
<p>All configuration data is read from the configuration text file serialproxy.rc which can be stored either locally under the corresponding dot file or globally under /etc/serialproxy.rc</p>
<p>Serialproxy comes with a default configuration which can be checked and evaluated on an arbitrary Linux host using the following commands. You need to have socat installed on this machine which is used to create another pseudo terminal device file for emulation of the UART: </p><pre class="fragment">socat -d -d pty,raw,echo=0,link=/tmp/phy pty,raw,echo=0,link=/tmp/test
</pre><p>The above socat command creates two linked pseudo terminal device files, the file /tmp/phy is accessed by serialproxy, the file /tmp/test would be accessed by the user application. Use in example minicom to try this out by adjusting the minicom's serial device to /tmp/uart.</p>
<p>Now start the serialproxy either from a shell or via an startup script which is not part of this package. The daemon writes all logging information to syslog so make sure you observe its syslog output. As indicated in syslog, serialproxy creates a symbolic link to the pseudo terminal file it uses which is store using the default configuration to /tmp/symlink. When you open up a 2nd minicom instance with this device file, you shall observe the input from one terminal transformed to upper case characters on the other's terminal output.</p>
<p>Of course you can directly access a 'physical' UART device file instead of using socat but not all Linux boxes are equipped with one these days. We decided to to focus on the socat based example for this reason instead.</p>
<h2>License</h2>
<p>This implementation code stands under the terms of the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.</p>
<p>June 2017, Otto Linnemann </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 12 2017 18:21:25 for serialproxy by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
